available.packages()
head(rownames(available.packages(),3))
head(rownames(available.packages(),1))
head(rownames(available.packages(),6))
head(rownames(available.packages(),7))
install.packages(slidify)
install.packages("slidify")
install.packages('slidify')
install.packages(c("slidify","ggplot2"))
source("http://bioconductor.org/biocLite.R")
library(ggplot2)
library(BiocInstaller)
library(digest)
search()
install.packages(rtools)
install.packages("rtools")
install.packages("Kern Smooth")
install.packages("KernSmooth")
library(KernSmooth)
install.packages(dev.tools)
install.packages(devtools)
install.packages("dev.tools")
install.packages("devtools")
library(devtolls)
library(devtools)
find_rtools()
exit
quit
exit()
f<-vector("numeric",lenght=10)
f<-vector("numeric",length=10)
f
x<-0:6
#what class is x currently
class(x)
#show x as a number
as.numeric(x)
#show x as a logical (TRUE/FALSE statement)
as.logical(x)
#show x as a string (using "")
as.character(x)
x<-c("a","b","c")
as.number(x)
as.numeric(x)
msg<- "hello"
msg
rm(msg)
m
m<-matrix(nrow=1,ncol=3)
m
m<-matrix(nrow=2,ncol=3)
m
dim(m)
?attribute()
?attributes()
attributes(x)
attritubes(m)
attributes(m)
x<-1:20
x
x
m<-matrix(1:6, nrow=2,ncol=3)
m
m<-matrix(1:5, nrow=2,ncol=3)
m
1
1L
1/inf
inf()
1/Inft
1/Inf
c(TRUE,2)
y<-c(TRUE,2)
y
y<-c("a",TRUE)
y
x<-0:6
#what class is x currently
class(x)
m<-1:10
m
#now we modify the vector (which is a 1xn matrix) to a matrix using dim()
#this gives us a 2x5 matrix, using the vector 1x10
dim(m) <-c(2,5)
m
x
y
x<-1:3
y<-10:12
x
y
cbind(x,y)
x<-1:2
cbind(x,y)
rbind(y,x)
x<-1:3
rbind(y,x)
x<-list(1,"a",TRUE,1+4i)
x
x<-c("list",length=5)
x
?c
x<-vector("list",length=5)
x
?vector()
?glm()
x<-factor(c("yes","yes","no","yes","no"))
table(x)
unclass(x)
x<-factor(c("yes","yes","no","yes","no"),
levels=c("yes","no"))
x
x<-factor(c("yes","yes","no","yes","no"))
x
x<-factor(c("yes","yes","no","yes","no"),
levels=c("yes","no"))
x
table(x)
unclass(x)
x<-c(1,2,NA,10,3)
is.na(x)
is.nan(x)
x<-c(1,2,NaN,NA,4)
is.na(x)
is.na(x)
is.nan(x)
x<-data.frame(foo=1:4, bar=c(T,T,F,F))
x
nrow(x)
ncol(x)
x<-1:3
names(x)
names(x)<-c("foo","bar","norf")
x
names(x)
m<-matrix(1:4,nrom=2,ncol=2)
dimnames(m)<-list(c("a","b"),c("c","d"))
m
m<-matrix(1:4,nrow=2,ncol=2)
m
dimnames(m)<-list(c("a","b"),c("c","d"))
m
x<-list(1:3)
x
x<-list(1,2,3)
x
x<-list()
x
x<-list(a=1,b=2,c=3)
x
?sapply()
?class
taba
y<-data.frame(a=1,b="a")
dput(y)
dput(y,file="y.R")
new.y<-dget("y.R")
new.y
dput(y,file="y.R")
clear
clear()
rm new.y
rm(new.y)
rm(y)
new.y<-dget("y.R")
new.y
x<-"foo"
x
class(x)
y<-data.frame(a=1,b="a")
class(y)
y
dump(c("x","y"),file="data.R")
rm(x,y)
source("data.R")
y
x
str(file)
con<-url("http://www.jhsph.edu","r")
con
con
x<-readLines(con)
x
head(x)
x<-c("a","b","c","c","d","a")
x[1:4]
?unclass()
x<-rnorm(100,1,1)
install.packages("Ckmeans.1d.dp")
library(Ckmeans.1d.dp)
Ckmeans.1d.dp(x,10)
?Ckmeans.1d.dp
Ckmeans.1d.dp(x,c(1,10)
Ckmeans.1d.dp(x,c(1,10))
plot(x,col=result$cluster,pch=result$cluster,cex=1.5,main="Optimal k-means clustering")
y<-Ckmeans.1d.dp(x,c(1,10))
y
plot(x,col=y$cluster,pch=y$cluster,cex=1.5,main="Optimal k-means clustering")
x<-df(x)
x<-as.dataframe(x)
x<-as.data.frame(x)
View(x)
Ckmeans.1d.dp(x,10)
View(x)
Ckmeans.1d.dp(x,10)
Ckmeans.1d.dp(x,2)
?<<
rm(y,x)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
makeVector(5)
getwd()
setwd("C:/Users/Thomas Fruehauf/Documents/Coursera/Course 2/ProgrammingAssignment2")
setwd("C:/Users/Thomas Fruehauf/Documents/Coursera/Data Science/Course 2/ProgrammingAssignment2")
source("cachematrix.R")
View(makeCacheMatrix)
View(cacheSolve)
View(makeVector)
View(cacheSolve)
View(makeCacheMatrix)
View(cacheSolve)
View(makeCacheMatrix)
View(cacheSolve)
View(makeCacheMatrix)
View(makeVector)
View(makeVector)
makeCacheMatrix <- function(x = matrix()) {
m<-NULL
set<-function(y)
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y)
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
trackerror()
traceback()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(inverse) m <<- inverse
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m=makeCacheMatrix(x)
m$get()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
#Creating empty m matrix that is going to store the inversion calculation once it's calculated for the first time.
makeCacheMatrix <- function(x = matrix()) {
cached.inverse <- NULL
set <- function(y) {
#Both x and m are defined in a different environment, which is why we use "<<-".
x <<- y
cached.inverse <<- NULL
}
#Setting the inverse of matrix x and getting the inverse of that matrix -matrix m.
get <- function() x
setinverse <- function(inverse) cached.inverse <<- inverse
getinverse <- function() cached.inverse
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
cached.inverse <- x$getinverse()
if(!is.null(cached.inverse)) {
message("getting cached data")
return(cached.inverse)
}
data <- x$get()
cached.inverse <- solve(data, ...)
x$setinverse(cached.inverse)
cached.inverse
}
x = rbind(c(1, -1/4), c(-1/4, 1))
cached.inverse=makeCacheMatrix(x)
cached.inverse$get()
